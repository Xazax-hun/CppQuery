"ctorInitializer" <<
"accessSpecDecl" <<
"classTemplateDecl" <<
"classTemplateSpecializationDecl" <<
"constructorDecl" <<
"decl" <<
"declaratorDecl" <<
"destructorDecl" <<
"enumConstantDecl" <<
"enumDecl" <<
"fieldDecl" <<
"friendDecl" <<
"functionDecl" <<
"functionTemplateDecl" <<
"methodDecl" <<
"namedDecl" <<
"namespaceDecl" <<
"parmVarDecl" <<
"recordDecl" <<
"unresolvedUsingValueDecl" <<
"usingDecl" <<
"varDecl" <<
"nestedNameSpecifierLoc" <<
"nestedNameSpecifier" <<
"qualType" <<
"arraySubscriptExpr" <<
"asmStmt" <<
"binaryOperator" <<
"bindTemporaryExpr" <<
"boolLiteral" <<
"breakStmt" <<
"cStyleCastExpr" <<
"callExpr" <<
"caseStmt" <<
"castExpr" <<
"catchStmt" <<
"characterLiteral" <<
"compoundLiteralExpr" <<
"compoundStmt" <<
"conditionalOperator" <<
"constCastExpr" <<
"constructExpr" <<
"continueStmt" <<
"declRefExpr" <<
"declStmt" <<
"defaultArgExpr" <<
"defaultStmt" <<
"deleteExpr" <<
"doStmt" <<
"dynamicCastExpr" <<
"explicitCastExpr" <<
"expr" <<
"floatLiteral" <<
"forRangeStmt" <<
"forStmt" <<
"functionalCastExpr" <<
"gotoStmt" <<
"ifStmt" <<
"implicitCastExpr" <<
"initListExpr" <<
"integerLiteral" <<
"labelStmt" <<
"lambdaExpr" <<
"materializeTemporaryExpr" <<
"memberCallExpr" <<
"memberExpr" <<
"newExpr" <<
"nullPtrLiteralExpr" <<
"nullStmt" <<
"operatorCallExpr" <<
"reinterpretCastExpr" <<
"returnStmt" <<
"staticCastExpr" <<
"stmt" <<
"stringLiteral" <<
"switchCase" <<
"switchStmt" <<
"temporaryObjectExpr" <<
"thisExpr" <<
"throwExpr" <<
"tryStmt" <<
"unaryExprOrTypeTraitExpr" <<
"unaryOperator" <<
"unresolvedConstructExpr" <<
"userDefinedLiteral" <<
"whileStmt" <<
"typeLoc" <<
"arrayType" <<
"atomicType" <<
"autoType" <<
"blockPointerType" <<
"builtinType" <<
"complexType" <<
"constantArrayType" <<
"dependentSizedArrayType" <<
"elaboratedType" <<
"functionType" <<
"incompleteArrayType" <<
"lValueReferenceType" <<
"memberPointerType" <<
"parenType" <<
"pointerType" <<
"rValueReferenceType" <<
"recordType" <<
"referenceType" <<
"templateSpecializationType" <<
"type" <<
"typedefType" <<
"unaryTransformType" <<
"variableArrayType" <<
"allOf" <<
"anyOf" <<
"anything" <<
"unless" <<
"hasOperatorName" <<
"equals" <<
"argumentCountIs" <<
"isImplicit" <<
"isWritten" <<
"hasOverloadedOperatorName" <<
"isConst" <<
"isOverride" <<
"isVirtual" <<
"isDerivedFrom" <<
"isExplicitTemplateSpecialization" <<
"isSameOrDerivedFrom" <<
"isTemplateInstantiation" <<
"statementCountIs" <<
"hasSize" <<
"declCountIs" <<
"equalsBoundNode" <<
"equalsNode" <<
"isPrivate" <<
"isProtected" <<
"isPublic" <<
"isDefinition" <<
"isExternC" <<
"parameterCountIs" <<
"isArrow" <<
"hasName" <<
"matchesName" <<
"asString" <<
"hasLocalQualifiers" <<
"isConstQualified" <<
"isInteger" <<
"ofKind" <<
"eachOf" <<
"forEach" <<
"forEachDescendant" <<
"has" <<
"hasAncestor" <<
"hasDescendant" <<
"hasParent" <<
"hasBase" <<
"hasIndex" <<
"hasElementTypeLoc" <<
"hasElementType" <<
"hasValueTypeLoc" <<
"hasValueType" <<
"hasDeducedType" <<
"hasEitherOperand" <<
"hasLHS" <<
"hasRHS" <<
"pointeeLoc" <<
"pointee" <<
"hasAnyArgument" <<
"hasArgument" <<
"hasDeclaration" <<
"forEachConstructorInitializer" <<
"hasAnyConstructorInitializer" <<
"forField" <<
"withInitializer" <<
"on" <<
"onImplicitObjectArgument" <<
"thisPointerType" <<
"ofClass" <<
"hasMethod" <<
"callee" <<
"hasCaseConstant" <<
"hasSourceExpression" <<
"hasAnyTemplateArgument" <<
"hasTemplateArgument" <<
"hasAnySubstatement" <<
"hasCondition" <<
"hasFalseExpression" <<
"hasTrueExpression" <<
"throughUsingDecl" <<
"to" <<
"containsDeclaration" <<
"hasSingleDecl" <<
"hasTypeLoc" <<
"hasDeclContext" <<
"hasBody" <<
"hasQualifier" <<
"namesType" <<
"hasDestinationType" <<
"hasType" <<
"ignoringImpCasts" <<
"ignoringParenCasts" <<
"ignoringParenImpCasts" <<
"hasIncrement" <<
"hasLoopInit" <<
"hasAnyParameter" <<
"hasParameter" <<
"returns" <<
"hasConditionVariableStatement" <<
"hasImplicitDestinationType" <<
"hasObjectExpression" <<
"member" <<
"hasPrefix" <<
"loc" <<
"specifiesTypeLoc" <<
"specifiesNamespace" <<
"specifiesType" <<
"innerType" <<
"hasCanonicalType" <<
"pointsTo" <<
"references" <<
"alignOfExpr" <<
"sizeOfExpr" <<
"forEachSwitchCase" <<
"refersToDeclaration" <<
"refersToType" <<
"findAll" <<
"hasArgumentOfType" <<
"hasUnaryOperand" <<
"hasAnyUsingShadowDecl" <<
"hasTargetDecl" <<
"hasInitializer" <<
"hasSizeExpr" <<
"bind"